# Lesson 1

## GITHUB

- зарегались на github.com
- создали репозиторий
- создали ключ ssh

```bash
ssh -keygen -t ed25519 -C "@mail"
```
- сохранили ключи
- закинули публичный ключ на GitHub (https://github.com/settings/keys)

установили инструменты разработчика 
```bash
xcode-select --install
```

- клонировали репозиторий на комп

```bash
git clone https://github.com/settings/keys
```
- открыли его в Visual Code
- Поставили HomeBrew (для установки разных вещей на Мac) - пакетный менеджер

```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```
- выполнили три команды которые он просит
- и установили питон
```bash
brew install python
```
- добавили новый интерпретатор в Visual code через путь к папке с ним

## Решили задачку с leet code
- написали функцию
- сохранили все на github
```bash
git status
git add
git commit -m
git push
```
# Lesson 2

- написали бинарный поиск
- познакомились с О() нотацией

# Lesson 3

## Сортировка

В зависимости от использования памяти:
- внутренняя
- внешняя

Важное свойство - устойчивость:
- устойчивая сортировка не меняет относительно положение одинаковых элементов

Пример сортировок:
- сортировка пузырьком: О(n^2) элементы меняются попарно, если левый больше правого
- шейкерная сортировка: O(n^2) вариант сортировки пузырьком, при котором мы идем по массиву то слева направо, то справа налево; границы рабочей части массива устанавливаютс в месте последнего обмена

## Merge sort (сортировка слиянием): 
O(n log n)
-  разделяем на несколько маленьких, сортируем, объединяем. Будет выгоднее, чем сортировать все, елси слияние не очень затратно по вычислениям.

Оффтоп: если у функции внутри класса есть декоратор @classmethod то ее можно вызывать напрямую из класса без объекта
``` 
Class Solution:
    @classmethod
    def test(cls):
        print('hello')
Solution.test()
```

- встроенный в Python sort() сортирует комбинацией merge sort и других методов. Называется TimSort

## посмотреть
- как узнать сколько места занимаем merge sort
- узнать почему нам достаточно n проходов, а не больше

в след раз: попробуем сделать быструю сортировку. можно заранее про нее и TimSort прочитать